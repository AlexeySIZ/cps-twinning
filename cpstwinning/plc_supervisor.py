#!/usr/bin/env python

from multiprocessing.connection import Listener
from subprocess import Popen
from threading import Event, Thread
from ctypes import c_void_p, c_int, byref, POINTER, cdll, addressof, cast, \
    c_bool, CFUNCTYPE

from pymodbus.server.sync import ModbusTcpServer
from pymodbus.device import ModbusDeviceIdentification
from pymodbus.datastore import ModbusSlaveContext, ModbusServerContext, ModbusSparseDataBlock, ModbusSequentialDataBlock
from pymodbus.transaction import ModbusRtuFramer, ModbusAsciiFramer
# from pymodbusexamples.thread_safe_datastore import ThreadSafeDataBlock

import utils
import os
import time
import signal
import sys
import csv
import logging
import pickle

# Logging
logging.basicConfig(filename='/tmp/cps-twinning.log', level=logging.DEBUG)

def info(out):
    logging.info(out)

def debug(out):
        logging.debug(out)


def error(out):
        logging.error(out)


class UnknownPlcTagException(Exception):
    pass


class PlcClasses(object):
    IN = "in"
    OUT = "out"
    VAR = "var"
    MEM = "mem"
    
    def __setattr__(self, *_):
        pass


class PlcTypes(object):
    INT = "int"
    BOOL = "bool"

    def __setattr__(self, *_):
        pass


class PlcSupervisor(object):
    
    def __init__(self):
        # TODO: Error handling
        self.name = sys.argv[1]
        st_path = sys.argv[2]
        mb_map_path = sys.argv[3]
        
        self.conn_watcher = []

        # Get value of DSTDIR key in Makefile
        self.tmp_path = utils.get_dstdir_path_from_mkfile(self.name)
        # Path of the VARIABLES.csv file, generated by MatIEC
        self.loc_vars_csv_path = '{}/VARIABLES.csv'.format(self.tmp_path)
        
        try:
            # Build lib
            self.__run_make(st_path)
    
            # Parse variables from CSV file and set them
            self.__set_vars()
            
            # Initialize Modbus map
            self.__init_modbus_map(mb_map_path)
    
            # Load lib
            self.lib = cdll.LoadLibrary("{}/lib{}.so".format(utils.get_dstdir_path_from_mkfile(self.name), self.name))
            
            # Private lib methods:
            self.__start_plc = self.lib.start_plc
            self.__start_plc.restype = c_int
            self.__stop_plc = self.lib.stop_plc
            self.__stop_plc.restype = c_int
            self.__get_ref_by_idx_p = self.lib.get_ref_by_idx_p
            self.__get_ref_by_idx_p.restype = c_int
            self.__get_ref_by_idx_p.argtypes = [c_int, POINTER(POINTER(c_void_p))]
            self.__get_ref_by_idx_t = self.lib.get_ref_by_idx_t
            self.__get_ref_by_idx_t.restype = c_int
            self.__get_ref_by_idx_t.argtypes = [c_int, POINTER(c_void_p)]
            self.__set_int_val_by_idx_p = self.lib.set_int_val_by_idx_p
            self.__set_int_val_by_idx_p.restype = c_int
            self.__set_int_val_by_idx_p.argtypes = [c_int, c_void_p]
            self.__set_int_val_by_idx_t = self.lib.set_int_val_by_idx_t
            self.__set_int_val_by_idx_t.restype = c_int
            self.__set_int_val_by_idx_t.argtypes = [c_int, c_void_p]
                
            # First arg is return type (= void), after that: method args
            self.callback_type = CFUNCTYPE(None, c_int)
            # Prevent GC, otherwise program will fail with:
            # Traceback (most recent call last):
            #   File "_ctypes/callbacks.c", line 314, in 'calling callback function'
            # TypeError: <genexpr>() takes exactly 1 argument (2 given)
            self.callback_func = self.get_callback_function()
            
            self.__register_var_change_callback = self.lib.register_var_change_callback
            self.__register_var_change_callback.restype = None
            self.__register_var_change_callback.argtypes = [self.callback_type]
            self.__register_var_change_callback(self.callback_func)
    
            # PLC initially not running
            self.running = False
            # Start PLC
            self.start()
            # Finally, initialize listener for socket communication
            self.__init_listener()
        except Exception as e:
            error(e)

    def __init_listener(self):
        address = ('', 6000)
        listener = Listener(address)
        while True:
            conn = listener.accept()
            debug('Connection accepted from {}.'.format(listener.last_accepted))
            msg = conn.recv()
            args = msg.split()
            cmd = args[0]
            if cmd == 'start':
                conn.send(self.start())
            elif cmd == 'stop':
                conn.send(self.stop())
            elif cmd == 'show_tags':
                conn.send(self.vars)
            elif cmd == 'get':
                try:
                    res = self.get_var_value(args[1])
                except UnknownPlcTagException as e:
                    res = e
                conn.send(res)
            elif cmd == 'set':
                dict_var = dict((args[1].split('='),))
                for k, v in dict_var.iteritems():
                    conn.send(self.set_var_value(k, v))
            elif cmd == 'monitor':
                var_names = []
                for x in args[1:]:
                    if any(d['name'].upper() == x.upper() for d in self.vars):
                        var_names.append(x.upper())
                    else:
                        error('Found invalid var {} when trying to monitor PLC variable.\n'.format(x))
                self.conn_watcher.append({'conn': conn, 'var_names': var_names})
            elif cmd == 'terminate':
                self.stop()
                self.plc_thread.join()
            elif cmd == 'close':
                conn.close()
                break
        listener.close()
        
    def __init_modbus_map(self, mb_map_path):
        if mb_map_path:
            with open(mb_map_path, 'rb') as handle:
                tmp_mb_map = pickle.loads(handle.read())
                # Replace the name of the PLC var with its respective index in the vars list
                for ktbl, vtbl in tmp_mb_map.iteritems():
                    for k, v in vtbl.iteritems():
                        vtbl[k] = self.vars.index(filter(lambda n: n.get('name').lower() == v.lower(), self.vars)[0])
            # { address: idx }
            # address: Modbus address (must start at 1)
            # idx: index of vars array
            self.mb_map = tmp_mb_map
    
    def __notify_watcher(self, idx, new_value):
        for conn_el in self.conn_watcher:
            var_name = self.vars[idx]['name']
            if var_name in conn_el['var_names']:
                try:
                    data = {'name': var_name, 'value': new_value}
                    conn_el['conn'].send(data) 
                except:
                    # Socket is no longer alive
                    del self.conn_watcher[self.conn_watcher.index(conn_el)]
    
    def __sync_mb_blocks(self, idx, new_value):
        def get_mb_addr_to_set_tpl():
                for tbl, v in self.mb_map.iteritems():
                    for addr, jdx in v.iteritems():
                        if idx == jdx:
                            # Contains (table name, modbus address)
                            # table name = di, co, hr or ir
                            return (tbl, addr)
            
        def set_blk_val(block, addr, new_value):
            block.setValues(addr, [new_value], clbk=False)
        
        mb_addr_to_set = get_mb_addr_to_set_tpl()
        if mb_addr_to_set:
            tbl, addr = mb_addr_to_set
            blk = self.mb_blocks[tbl]
            set_blk_val(blk, addr, new_value)

    # Workaround using closures to make ctypes function callback work with class methods
    # See: https://stackoverflow.com/a/7261524/8516723
    def get_callback_function(self):

        def my_callback(idx):
            # Unfortunately, we currently cannot pass the new value from the do_notify method to 
            # the callback, because we don't know the type of the variable set statement 
            # per compile-time. Therefore, we have to retrieve the new value now.
            new_value = self.get_var_value(self.vars[idx]['name'])
            self.__sync_mb_blocks(idx, new_value)
            self.__notify_watcher(idx, new_value)

        return self.callback_type(my_callback)

    def terminate(self):
        self.stop()
        self.plc_thread.join()

    def __run_make(self, path_to_st):
        
        def set_conf_res_env():
            # Open csv file
            with open(self.loc_vars_csv_path, 'r') as f:
                # Parse programs section
                progs_reader = csv.reader(utils.filter_vars_csv_section(utils.programs_pattern_obj, f), delimiter=';')
                for row in progs_reader:
                    # Example row:
                    # 0;STD_CONF.STD_RESSOURCE.INST0;MY_PROGRAM;
                    # num;symbols;program_name
                    # symbols: configuration_name.ressource_name.instance_name
                    symbols = row[1].split('.')
                    configuration_name = symbols[0]
                    resource_name = symbols[1]
                    # Currently, we only support one program - so stop
                    break
                
                if configuration_name and resource_name:
                    # MatIEC generates the file names of the configuration and resource according to their
                    # name specified in ST code. Unfortunately, in VARIABLES.CSV, all elements are in upper-case.
                    try:
                        files = os.listdir(self.tmp_path)
                    except OSError:
                        return
                    
                    configuration_file_name = ''
                    resource_file_name = ''
                    
                    for f in files:
                        f_name = os.path.splitext(f)[0]
                        if f_name.lower() == configuration_name.lower():
                            configuration_file_name = f_name
                        elif f_name.lower() == resource_name.lower():
                            resource_file_name = f_name
                        if configuration_file_name and resource_file_name:
                            break
                    
                    if configuration_file_name and resource_file_name:
                        os.environ["ST_CONFIGURATION_NAME"] = configuration_file_name
                        os.environ["ST_RESOURCE_NAME"] = resource_file_name
                    else:
                        raise RuntimeError('Could not find matching configuration and resource name.')
                else:
                    raise RuntimeError('Could not find configuration name and resource name in {}.'.format(loc_vars_csv_path))
        
        # Validate path
        if not os.path.isfile(path_to_st):
            error("The ST file path '{}' is not valid!\n".format(path_to_st))
            return
        
        # Check if MatIEC env variables are set
        matiec_inc_path = "MATIEC_INCLUDE_PATH"
        matiec_c_inc_path = "MATIEC_C_INCLUDE_PATH"

        if matiec_inc_path not in  os.environ:
            error("The environment variable '{}' is not set.\n".format(matiec_inc_path))
            return
        if matiec_c_inc_path  not in os.environ:
            error("The environment variable '{}' is not set.\n".format(matiec_c_inc_path))
            return
        
        # Set env variables
        os.environ["ST_FILE_PATH"] = path_to_st
        os.environ["PLC_NAME"] = self.name

        # Run make targets
        cwd = os.path.join(os.path.dirname(os.path.realpath(__file__)) , 'plcruntime')
        # Run make init
        mkinit = Popen(['make', 'init'], shell=False, cwd=cwd).wait()
        if mkinit is not 0:
            error("Executing make target 'init' failed.")
            return
        debug('Return value of target init: {}.'.format(mkinit))
        
        # Run make iec2c
        mkiec2c = Popen(['make', 'iec2c'], shell=False, cwd=cwd).wait()
        if mkiec2c is not 0:
            error("Executing make target 'iec2c' failed.")
            return
        
        debug('Return value of target iec2c: {}.'.format(mkiec2c))
        
        set_conf_res_env() 
        
        # Run make build
        mkbuild = Popen(['make', 'build'], shell=False, cwd=cwd).wait()
        if mkbuild is not 0:
            error("Executing make target 'build' failed.")
            return
        
        debug('Return value of target build: {}.'.format(mkbuild))
        
    def __set_vars(self):
        # Init vars
        self.vars = []
        # Open csv file
        with open(self.loc_vars_csv_path, 'r') as f:
            # First parse programs section
            progs_reader = csv.reader(utils.filter_vars_csv_section(utils.programs_pattern_obj, f), delimiter=';')
            for row in progs_reader:
                # Example row:
                # 0;STD_CONF.STD_RESSOURCE.INST0;MY_PROGRAM;
                # num;symbols;program_name
                # symbols: configuration_name.ressource_name.instance_name
                symbols_prog = row[1]
                break
            
            # Parse variables section
            vars_reader = csv.reader(utils.filter_vars_csv_section(utils.variables_pattern_obj, f), delimiter=';')
            for row in vars_reader:
                # Example row:
                # 1;IN;STD_CONF.STD_RESSOURCE.INST0.TEMPERATURE;STD_CONF.STD_RESSOURCE.INST0.TEMPERATURE;INT;
                # num;class;symbols;symbols?;datatype
                parsed_clazz = row[1]
                # Skip function blocks
                if parsed_clazz == 'FB':
                    continue
                symbols = row[3]
                var_name = "".join(symbols.rsplit(symbols_prog + '.'))
                clazz = self.__get_internal_plc_class(parsed_clazz)
                parsed_type = row[-2]
                type = self.__get_internal_plc_type(parsed_type)
                self.vars.append({'class': clazz, 'name': var_name, 'type': type})
                    
    def __get_internal_plc_type(self, type):
        if type == "INT":
            return PlcTypes().INT
        elif type == "BOOL":
            return PlcTypes().BOOL
        else:
            raise RuntimeError("Type: '{}' is currently not supported.".format(type))
        
    def __get_internal_plc_class(self, clazz):
        if clazz == "IN":
            return PlcClasses().IN
        elif clazz == "OUT":
            return PlcClasses().OUT
        elif clazz == "VAR":
            return PlcClasses().VAR
        elif clazz == "MEM":
            return PlcClasses().MEM
        else:
            raise RuntimeError("Class: '{}' is currently not supported.".format(clazz))
     
    def start(self):
        
        def get_data_block_values(d):
            return dict(map(lambda (k, v): (k, 0), d.iteritems()))
        
        def get_blocks():
            blocks = {}
            for k, v in self.mb_map.iteritems():
                vals = get_data_block_values(v)
                if vals:
                    clbk = None
                    if k == 'di':
                        clbk = self.mb_di_callback
                    elif k == 'co':
                        clbk = self.mb_co_callback
                    elif k == 'hr':
                        clbk = self.mb_hr_callback
                    elif k == 'ir':
                        clbk = self.mb_ir_callback
                    else:
                        raise RuntimeError('Unknown MB type.')
                    blocks[k] = PlcSupervisorDataBlock(vals, clbk)
            return blocks
        
        if self.running:
            return "PLC already running. Nothing to start..."
        else:
            # Modbus Thread stuff
            # FIXME: Make custom Modbus data block thread-safe
            # self.block = ThreadSafeDataBlock(PlcSupervisorDataBlock(0, [0] * 1000, self.modbus_callback))
            self.mb_blocks = get_blocks()
            
            self.modbus_server_thread = ModbusServerThread(('', 502), self.mb_blocks)
            self.modbus_server_thread.daemon = True
            self.modbus_server_thread.start()
            # PLC Thread stuff
            self.stop_event = Event()
            self.plc_thread = PlcStartThread(self)
            self.plc_thread.daemon = True
            self.plc_thread.start()
            # Make lib call
            res = self.__start_plc()
            if res == 0:
                self.running = True
                return ""
            else:
                self.stop_event.set()
                return "Error when starting PLC."
        
    def mb_di_callback(self, address, values):
        self.__mb_callback(self.mb_map['di'], address, values)
        
    def mb_co_callback(self, address, values):
        self.__mb_callback(self.mb_map['co'], address, values)
        
    def mb_hr_callback(self, address, values):
        self.__mb_callback(self.mb_map['hr'], address, values)

    def mb_ir_callback(self, address, values):
        self.__mb_callback(self.mb_map['ir'], address, values)
        
    def __mb_callback(self, block, address, values):
        idx = block[address]
        self.set_var_value(self.vars[idx]['name'], str(values[0]))
        # TODO: Implement Write Multi-Functions (FC15, FC16)
        
    def stop(self):
        if self.running:
            debug("Stopping PLC '{}' now...\n".format(self.name))
            # Stopping Modbus server
            self.modbus_server_thread.stop()
            self.modbus_server_thread.join()
            # Stopping PLC
            res = self.__stop_plc()
            if res == 0:
                self.stop_event.set()
                self.running = False
                return ""
            else:
                return "Error when stopping PLC."
        else:
            return "PLC not running. Nothing to stop..."
        
    def get_var_value(self, name):
        for d in self.vars:
            # Check if variable exists in PLC code
            if d['name'] == name:
                # Prepare args for lib call
                idx = c_int(self.vars.index(d))
                clazz = d['class']
                plc_clazzes = PlcClasses()
                if  clazz == plc_clazzes.IN or clazz == plc_clazzes.OUT or clazz == plc_clazzes.MEM:
                    ptr = POINTER(c_void_p)()
                    res = self.__get_ref_by_idx_p(idx, byref(ptr))
                elif clazz == plc_clazzes.VAR:
                    ptr = c_void_p()
                    res = self.__get_ref_by_idx_t(idx, byref(ptr))
                else:
                    raise RuntimeError("Class '{}' currently not supported.\n".format(clazz))
                if res == 0:
                    type = None
                    types = PlcTypes()
                    if d['type'] == types.INT:
                        type = POINTER(c_int)
                    elif d['type'] == types.BOOL:
                        type = POINTER(c_bool)
                    if type is None:
                        raise RuntimeError("Type: '{}' is currently not supported.".format(d['type']))
                    var_res = cast(self.__get_ptr_accessor(clazz, ptr), type)
                    return var_res[0]
                else:
                   raise RuntimeError("Error! Lib call 'get_ref_by_idx' returned error.") 
        
        raise UnknownPlcTagException("Variable name '{}' does not exist in PLC.\n".format(name))
    
    def __get_ptr_accessor(self, clazz, ptr):
        plc_clazzes = PlcClasses()
        if clazz == plc_clazzes.IN or clazz == plc_clazzes.OUT or clazz == plc_clazzes.MEM:
            return ptr[0]
        elif clazz == plc_clazzes.VAR:
            return ptr
        else:
            raise RuntimeError("Class '{}' currently not supported.\n".format(clazz))
        
    def set_var_value(self, name, value):
        for d in self.vars:
            # Check if variable exists in PLC code
            if d['name'] == name:
                new_value = None
                old_value = self.get_var_value(name)
                val_to_sync = None
                types = PlcTypes()
                clazz = d['class']
                plc_clazzes = PlcClasses()
                type = d['type']
                # Prepare args for lib call
                idx = self.vars.index(d)
                c_idx = c_int(idx)
                if type == types.INT:
                    val_to_sync = int(value)
                    new_value = c_int(val_to_sync)
                elif type == types.BOOL:
                    # Value sent via Modbus may be 0/1 
                    val_to_sync = value.lower() == "true" or value == "1"
                    new_value = c_bool(val_to_sync)
                    
                if new_value is None:
                    raise RuntimeError("Type: '{}' is currently not supported.".format(type))

                if  clazz == plc_clazzes.IN or clazz == plc_clazzes.OUT or clazz == plc_clazzes.MEM:
                    # TODO: Error handling
                    res = self.__set_int_val_by_idx_p(c_idx, byref(new_value))
                elif clazz == plc_clazzes.VAR:
                    # TODO: Error handling
                    res = self.__set_int_val_by_idx_t(c_idx, byref(new_value))
                else:
                    raise RuntimeError("Class '{}' currently not supported.\n".format(clazz))
                if res != 0:
                   raise RuntimeError("Error! Lib call 'set_val_by_idx' returned error.")
                else:
                    info("'{}' value changed {} -> {} in device '{}'.".format(name, old_value, val_to_sync, self.name))
                    self.__sync_mb_blocks(idx, val_to_sync)
                    self.__notify_watcher(idx, val_to_sync)
                    return ""

        raise UnknownPlcTagException("Variable name '{}' does not exist in PLC.\n".format(name))


class PlcStartThread(Thread):
    
    def __init__(self, plc):
        Thread.__init__(self)
        self.plc = plc
        
    def run(self):
        debug("Starting PLC '{}' start-thread...\n".format(self.plc.name))
        # Waiting until stop_plc lib call has been executed
        self.plc.stop_event.wait()
        debug("Exiting PLC '{}' start-thread...\n".format(self.plc.name))


class PlcSupervisorDataBlock(ModbusSparseDataBlock):
    
    def __init__(self, values, clbk):
        self.callback = clbk
        super(PlcSupervisorDataBlock, self).__init__(values)
    
    def setValues(self, address, values, clbk=True):
        super(PlcSupervisorDataBlock, self).setValues(address, values)
        if clbk:
            self.callback(address, values)
        # print 'setValues {}; {}'.format(address, values)

    def getValues(self, address, values):
        # print 'getValues {}; {}'.format(address, values)
        return super(PlcSupervisorDataBlock, self).getValues(address, values)


class ModbusServerThread(Thread):
    
    def __init__(self, address, blocks):
        Thread.__init__(self)
        store = ModbusSlaveContext(
            di=blocks.get('di', ModbusSequentialDataBlock(0, [0])),
             co=blocks.get('co', ModbusSequentialDataBlock(0, [0])),
             hr=blocks.get('hr', ModbusSequentialDataBlock(0, [0])),
             ir=blocks.get('ir', ModbusSequentialDataBlock(0, [0])))
        self.context = ModbusServerContext(slaves=store, single=True)
        self.server = ModbusTcpServer(context=self.context, framer=None, identity=None, address=address)
        
    def run(self):
        self.server.serve_forever()
        
    def stop(self):
        self.server.server_close()
        self.server.shutdown()


def main():
    PlcSupervisor()


if __name__ == '__main__':
    main()
